**原因：**Android为每一个应用分配了一个独立的虚拟机，也就是说为每一个进程都分配了一个独立的虚拟机，这样导致不同的虚拟机在内存分配上存在不同的地址空间。这就是问题1，2的原因，问题3是因为SharedPrefences不支持两个进程同时去执行写操作，否则会导致一定的机率的数据丢失，这是因为Shared{refences的底层是通过读、写xml文件实现的，并发写很显然是会出问题的。问题4是因为当一个新的组件跑在一个新的进程的过程中的时候，系统会在创建新的进程的时候分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程，所以会重复的创建新的Application。总结来讲：不同的进程会拥有不同的虚拟机，application, 以及内存空间。

**方式：**​

| 名称 | 优点 | 缺点 | 场景 |
| :--- | :--- | :--- | :--- |
| Bundle | 简单易用 | 只能传输Bundle支持的数据类型 | Activity，Service，Receiver间的进程间通信 |
| 文件共享 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即时通信 | 无并发访问情形，交换简单的数据是实时不高的场景 |
| AIDL（继承自接口名.Stub实现接口内方法） | 功能强大，支持一对多并发通信，支持实时通信 | 使用稍复杂，需要处理好线程同步 | 一对多通信具有RPC需求 |
| Messenger（轻量级IPC，需要一个Handler） | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好的处理高并发情形，不支持RPC，数据通过Message进行传输，因此zhinengchuanshuBundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求，或者无需要返回结果的RPC需求 |
| ContentProvider（底层实现可以利用文件，SQLite，内存对象等） | 在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法拓展其他操作 | 可以理解为受约束的AIDL，主要提供数据源的增删改查的操作 | 一对多的进程间的数据共享 |
| Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节稍微繁琐，不支持直接的RPC | 网络数据交换 |
| BinderPool（利用BinderPool来管理Binder） | 避免了多次创建Service | 使用稍微复杂，需要额外实现BinderPool的AIDL接口 |  |

**目的：**

1. 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。

2. 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。

3. 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。

4. 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。

5. 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。



