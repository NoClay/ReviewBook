# 排序算法对比

![](http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg)

# 排序的稳定性

关于排序的稳定性，我们可以举一个例子，我们计划将公司的员工按照年龄排序，那么具体年龄对照表如下：

| 小a | 小d | 小w | 小s | 小t | 小e |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 23 | 21 | 21 | 34 | 25 | 26 |

那么我们希望排完序的结果是：

| 小d | 小w | 小a | 小t | 小e | 小s |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 21 | 21 | 23 | 35 | 26 | 34 |

这就是我们追求的稳定性，相同关键字的记录之间的相对次序不发生变化。

# 排序的分类

1. **插入类：**将无序的子序列中的一个或者几个记录，插入到有序序列中，从而增加记录的有序子序列的长度，如**插入排序**，**shell排序**

2. **选择类：**从无序子序列中选择关键字最小或者最大的记录，将它加入到有序子序列中，从而增加记录的有序子序列的长度。如**直接选择排序**，**堆排序**

3. **交换类：**通过交换无序子序列中的记录从而得到其中关键字最小或者最大的记录，并将它加入到有序子序列中，从而增加记录的有序子序列的长度，如**冒泡排序**，**快速排序**

4. **归并类：**通过“归并”两个或两个以上的记录有序子序列，逐步增加有序子序列的长度，如**归并排序**

5. **分配类：**是惟一一个不需要进行关键字之间的比较的排序算法，它主要利用分配和手机两种基本操作实现整个排序过程。如**木桶排序**，**基数排序**，**计数排序**



