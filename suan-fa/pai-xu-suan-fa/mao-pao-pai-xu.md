### 2. 冒泡排序（改进版）

**思想：**加flag岗哨，每一次遍历，都会把前边未排序部分的最大值冒出来，放到最后

**最佳运行时间：**O\(n\)

**最坏运行时间：**O\(n^2\)

**具体实现：**

```java
/**
     * 冒泡排序，从前向后
     *
     * @param data
     * @return
     */
    static int[] bubbleSort(int[] data) {
        if (data == null || data.length <= 0) {
            return null;
        }
        int[] result = new int[data.length];
        result = Arrays.copyOf(data, data.length);
        for (int i = result.length; i > 0; i--) {
            boolean flag = false;
            for (int j = 0; j < i - 1; j++) {
                if (result[j] > result[j + 1]) {
                    flag = true;
                    swap(result, j, j + 1);
                }
            }
            if (!flag) {
                break;
            }
        }
        return result;
    }
```

**证明算法正确性：**

运用两次循环不变式，先证明第4-6行的内循环，再证明外循环。

内循环不变式：在每次循环开始前，A\[j\]是A\[j...n\]中最小的元素。

初始：j=n，因此A\[n\]是A\[n...n\]的最小元素。

保持：当循环开始时，已知A\[j\]是A\[j...n\]的最小元素，将A\[j\]与A\[j-1\]比较，并将较小者放在j-1位置，因此能够说明A\[j-1\]是A\[j-1...n\]的最小元素，因此循环不变式保持。

终止：j=i，已知A\[i\]是A\[i...n\]中最小的元素，证毕。

接下来证明外循环不变式：在每次循环之前，A\[1...i-1\]包含了A中最小的i-1个元素，且已排序：A\[1\]&lt;=A\[2\]&lt;=...&lt;=A\[i-1\]。

初始：i=1，因此A\[1..0\]=空，因此成立。

保持：当循环开始时，已知A\[1...i-1\]是A中最小的i-1个元素，且A\[1\]&lt;=A\[2\]&lt;=...&lt;=A\[i-1\]，根据内循环不变式，终止时A\[i\]是A\[i...n\]中最小的元素，因此A\[1...i\]包含了A中最小的i个元素，且A\[1\]&lt;=A\[2\]&lt;=...&lt;=A\[i-1\]&lt;=A\[i\]

终止：i=n+1，已知A\[1...n\]是A中最小的n个元素，且A\[1\]&lt;=A\[2\]&lt;=...&lt;=A\[n\]，得证。

**在算法导论思考题2-2中又问了”冒泡排序和插入排序哪个更快“呢？**

一般的人回答：“差不多吧，因为渐近时间都是O\(n^2\)”。

但是事实上不是这样的，插入排序的速度直接是逆序对的个数，而冒泡排序中执行“交换“的次数是逆序对的个数，因此冒泡排序执行的时间至少是逆序对的个数，因此插入排序的执行时间至少比冒泡排序快。

