### 4. 选择排序

**思想：**每一次从后边未排序的部分中选择最小的放到前边已经排序的部分

**最好情况时间：**O\(n^2\)。

**最坏情况时间：**O\(n^2\)。

**具体实现：**

```java
   /**
     * 选择排序
     *
     * @param data
     * @return
     */
    static int[] selectSort(int[] data) {
        if (data == null || data.length <= 0) {
            return null;
        }
        int[] result = new int[data.length];
        result = Arrays.copyOf(data, data.length);
        for (int i = 0; i < result.length; i++) {
            int min = i;
            for (int j = i + 1; j < result.length; j++) {
                if (result[min] > result[j]) {
                    min = j;
                }
            }
            swap(result, i, min);
        }
        return result;
    }
```

**证明算法正确性：**

**循环不变式**：A\[1...i-1\]包含了A中最小的i-1个元素，且已排序。

**初始**：i=1，A\[1...0\]=空，因此成立。

**保持**：在某次迭代开始之前，保持循环不变式，即A\[1...i-1\]包含了A中最小的i-1个元素，且已排序，则进入循环体后，程序从         A\[i...n\]中找出最小值放在A\[i\]处，因此A\[1...i\]包含了A中最小的i个元素，且已排序，而i++，因此下一次循环之前，保持       循环不变式：A\[1..i-1\]包含了A中最小的i-1个元素，且已排序。

**终止**：i=n，已知A\[1...n-1\]包含了A中最小的i-1个元素，且已排序，因此A\[n\]中的元素是最大的，因此A\[1...n\]已排序，证毕。

**算法导论2.2-2中问了"为什么伪代码中第3行只有循环n-1次而不是n次"？**

在循环不变式证明中也提到了，如果A\[1...n-1\]已排序，且包含了A中最小的n-1个元素，则A\[n\]肯定是最大的，因此肯定是已排序的。

# 优化

树形选择排序：利用树形选择，将整数数组看作二叉树的叶子结点，从下往上，将两个子结点的最小值作为父节点的值，直到最后的根节点就是最小值，然后放入已经排序的数组的末位，同时将原来的该叶子节点值设为无穷大，更新叶子结点所属的祖宗树结点，直到所有的结点已经排序完成。 但是增加了n-1个辅助空间,时间复杂度如下：

$$O(n\log_2 n)$$

