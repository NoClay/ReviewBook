# 垃圾回收机制

GC是垃圾回收机制，java中将内存管理交给垃圾回收机制，**这是因为在面向对象编程中一个对象的生命周期往往无法预料，所以我们无法为每个对象指定回收时机。**

**但是我们可以采用**`System.gc()`**和**`Runtime.getRuntime().gc()`**进行请求垃圾回收，可以使用对象的**`finalize()`**对必要资源在垃圾回收之前进行处理。**

**优点：**使得java程序员不需要考虑内存管理，由于垃圾回收机制，java中的**对象不再有作用域的限制，只有对象的引用有作用域，可以有效的防止内存泄漏，有效的使用有限的可以使用的内存。**

# 垃圾收集算法

1. **标记-清扫（Mark-and-sweep）**---sun前期版本就是用这个技术。 原理：对于“活”的对象，一定可以追溯到其存活在堆栈、静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。第一阶段：从GC roots开始遍历所有的引用，对有活的对象进行标记。第二阶段：对堆进行遍历，把未标记的对象进行清除。**这个解决了循环引用的问题。 缺点：1、暂停整个应用；2、会产生内存碎片。**

2. **复制（copying） 原理：**为了提升效率，把内存空间划分为2个相等的区域，每次只使用一个区域。垃圾回收时，遍历当前使用区域，把正在使用的对象复制到另外一个区域。**优点：不会出现碎片问题。 缺点：1、暂停整个应用。2、需要2倍的内存空间。**

3. **标记-整理（Mark-Compact） 原理：**第一阶段标记活的对象，第二阶段把为标记的对象压缩到堆的其中一块，按顺序放。**即将所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。**优点：1、避免标记扫描的碎片问题；2、避免停止复制的空间问题。 具体使用什么方法GC，Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率低的话，就切换到“标记-扫描”方式；同样，Java虚拟机会跟踪“标记-扫描”的效果，要是堆空间碎片出现很多碎片，就会切换回“停止-复制”模式。这就是自适应的技术。

4. **分代（generational collecting）**-----J2SE1.2以后使用此算法 原理：基于对象生命周期分析得出的垃圾回收算法。把对象分为年轻代、年老代、持久代，对不同的生命周期使用不同的算法（2-3方法中的一个即4自适应）进行回收。

   * 新生代：每次垃圾收集都有大量对象死去，只有少量存活，就选择复制算法

   * 老年代：对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”，或者“标记-整理”算法来进行回收。

5. **自适应算法\(Adaptive Collector\)**在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。



