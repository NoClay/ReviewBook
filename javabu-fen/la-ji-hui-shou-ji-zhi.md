# 垃圾回收机制

GC是垃圾回收机制，java中将内存管理交给垃圾回收机制，**这是因为在面向对象编程中一个对象的生命周期往往无法预料，所以我们无法为每个对象指定回收时机。**

**但是我们可以采用**`System.gc()`**和**`Runtime.getRuntime().gc()`**进行请求垃圾回收，可以使用对象的**`finalize()`**对必要资源在垃圾回收之前进行处理。**

**优点：**使得java程序员不需要考虑内存管理，由于垃圾回收机制，java中的**对象不再有作用域的限制，只有对象的引用有作用域，可以有效的防止内存泄漏，有效的使用有限的可以使用的内存。**

1、**引用计数（reference counting）**​ 原理：此对象有一个引用，则+1；删除一个引用，则-1。只用收集计数为0的对象。​ **缺点：无法处理循环引用的问题**。如：对象A和B分别有字段b、a，令A.b=B和B.a=A，除此之外这2个对象再无任何引用，那实际上这2个对象已经不可能再被访问，但是引用计数算法却无法回收他们。

2、

3、

4、**标记-压缩（Mark-Compact）自适应​** 原理：第一阶段标记活的对象，第二阶段把为标记的对象压缩到堆的其中一块，按顺序放。​ **优点：1、避免标记扫描的碎片问题；2、避免停止复制的空间问题。​​** 具体使用什么方法GC，Java虚拟机会进行监视，**如果所有对象都很稳定，垃圾回收器的效率低的话，就切换到“标记-扫描”方式；同样，Java虚拟机会跟踪“标记-扫描”的效果，要是堆空间碎片出现很多碎片，就会切换回“停止-复制”模式。这就是自适应的技术。**

5、**分代（generational collecting）**-----J2SE1.2以后使用此算法​ 原理：基于对象生命周期分析得出的垃圾回收算法。把对象分为年轻代、年老代、持久代，对不同的生命周期使用不同的算法（2-3方法中的一个即4自适应）进行回收。

6、**自适应算法\(Adaptive Collector\)**​ 在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。

