# 垃圾回收机制

GC是垃圾回收机制，java中将内存管理交给垃圾回收机制，**这是因为在面向对象编程中一个对象的生命周期往往无法预料，所以我们无法为每个对象指定回收时机。**

**但是我们可以采用`System.gc()`和`Runtime.getRuntime().gc()`进行请求垃圾回收，可以使用对象的`finalize()`对必要资源在垃圾回收之前进行处理。**

**优点：**使得java程序员不需要考虑内存管理，由于垃圾回收机制，java中的**对象不再有作用域的限制，只有对象的引用有作用域，可以有效的防止内存泄漏，有效的使用有限的可以使用的内存。**

1、**引用计数（reference counting）**​ 原理：此对象有一个引用，则+1；删除一个引用，则-1。只用收集计数为0的对象。​ **缺点：无法处理循环引用的问题**。如：对象A和B分别有字段b、a，令A.b=B和B.a=A，除此之外这2个对象再无任何引用，那实际上这2个对象已经不可能再被访问，但是引用计数算法却无法回收他们。

2、**复制（copying）**​ 原理：把内存空间划分为2个相等的区域，每次只使用一个区域。垃圾回收时，遍历当前使用区域，把正在使用的对象复制到另外一个区域。​ **优点：不会出现碎片问题。​ 缺点：1、暂停整个应用。2、需要2倍的内存空间。**

3、**标记-清扫（Mark-and-sweep）**---sun前期版本就是用这个技术。​ 原理：对于“活”的对象，一定可以追溯到其存活在堆栈、静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。第一阶段：从GC roots开始遍历所有的引用，对有活的对象进行标记。第二阶段：对堆进行遍历，把未标记的对象进行清除。**这个解决了循环引用的问题。​ 缺点：1、暂停整个应用；2、会产生内存碎片。**

4、**标记-压缩（Mark-Compact）自适应​** 原理：第一阶段标记活的对象，第二阶段把为标记的对象压缩到堆的其中一块，按顺序放。​ **优点：1、避免标记扫描的碎片问题；2、避免停止复制的空间问题。​​** 具体使用什么方法GC，Java虚拟机会进行监视，**如果所有对象都很稳定，垃圾回收器的效率低的话，就切换到“标记-扫描”方式；同样，Java虚拟机会跟踪“标记-扫描”的效果，要是堆空间碎片出现很多碎片，就会切换回“停止-复制”模式。这就是自适应的技术。**

5、**分代（generational collecting）**-----J2SE1.2以后使用此算法​ 原理：基于对象生命周期分析得出的垃圾回收算法。把对象分为年轻代、年老代、持久代，对不同的生命周期使用不同的算法（2-3方法中的一个即4自适应）进行回收。

6、**自适应算法\(Adaptive Collector\)**​ 在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。

